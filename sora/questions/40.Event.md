# Chapter40 Questions

### 1. 사용자와 애플리케이션은 이벤트와 이벤트 핸들러를 통해 상호작용을 할 수 있는데, 이 과정에 대해 설명해주세요(브라우저의 이벤트 발생 과정).

- 브라우저가 사용자의 액션을 감지하여 해당 타입의 이벤트를 발생시킵니다. 그리고 그 이벤트에 대한 이벤트 객체를 생성합니다. 해당 이벤트 타입의 이벤트 핸들러가 등록되어 있다면, 그 이벤트 핸들러에 이벤트 객체를 인수로 전달하여 호출합니다.

#### 1.1 이벤트 핸들러를 직접 실행하지 않고 브라우저에게 위임하는 이유가 무엇인가요?

- 개발자가 사용자의 이벤트 발생 시점을 알 수 없기 때문에, 사용자의 액션을 감지할 수 있는 브라우저에게 이벤트 핸들러의 호출을 위임합니다.

#### 1.2 이벤트 드리븐 프로그래밍이 무엇인가요?

- 이벤트 드리븐 프로그래밍은 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 말합니다.

<br>

### 2. 이벤트 핸들러 등록 방식에 대해 비교하여 설명해주세요.

- 이벤트 핸들러 등록 방식은 3가지로 이벤트 핸들러 어트리뷰트 방식, 이벤트 핸들러 프로퍼티 방식, addEventListener 메서드 방식이 있습니다.
- 이벤트 핸들러 어트리뷰트 방식은 이벤트 핸들러 어트리뷰트의 값으로 함수 호출문을 할당합니다. 이벤트 핸들러 어트리뷰트의 값은 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미합니다. 따라서 이벤트 핸들러 어트리뷰트의 값은 여러 문으로 구성될 수 있습니다. 그리고 함수 호출문을 할당하므로, 함수에 인수를 전달할 수 있습니다. 한편으로는 HTML과 자바스크립트가 혼재되어 사용되므로 관심사의 분리가 되지 않았다고 볼 수 있습니다.
- 이벤트 핸들러 프로퍼티 방식은 이벤트 핸들러 프로퍼티에 함수를 할당하여 바인딩합니다. 이벤트 핸들러 프로퍼티 방식은 HTML과 자바스크립트가 뒤섞이는 문제를 해결할 수 있습니다. 그러나 이벤트 핸들러 프로퍼티에는 하나의 이벤트 핸들러만 바인딩할 수 있습니다.
- addEventListener 메서드 방식은 이벤트 핸들러를 바인딩하고자 하는 DOM 요소의 메서드로 호출하는 방식입니다. addEventListener 메서드의 첫 번째 인수로 이벤트 타입, 두 번째 인수로 이벤트 핸들러, 세 번째 인수로 이벤트를 캐치할 이벤트 전파 단계에 대한 불리언 값을 전달합니다. addEventListener 메서드 방식은 하나의 DOM 요소에 여러 개의 이벤트 핸들러를 바인딩할 수 있습니다. 또한 removeEventListener 메서드를 사용하여 이벤트 핸들러를 제거할 수 있습니다.

<br>

### 3. 이벤트 전파에 대해 설명해주세요.

- 이벤트가 발생하면 생성되는 이벤트 객체는 이벤트가 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파됩니다. 이를 이벤트 전파라고 합니다. 이벤트 전파는 이벤트 객체가 전파되는 방향에 따라 3단계인 캡처링 단계-타깃 단계-버블링 단계로 구분할 수 있습니다. -캡처링 단계는 상위 요소에서 하위 요소 방향으로 이벤트가 전파되는 단계입니다.
- 타깃 단계는 이벤트가 이벤트 타깃에 도달한 단계입니다.
- 버블링 단계는 하위 요소에서 상위 요소 방향으로 이벤트가 전파되는 단계입니다.

#### 3.1 버블링이 되지 않는 이벤트에 대해 설명해주세요.

- 버블링이 되지 않는 이벤트로는 포커스 이벤트 focus, blur, 리소스 이벤트 load, unload, abort, error, 마우스 이벤트 mouseenter, mouseleave 이벤트가 있습니다.
- 포커스 이벤트와 마우스 이벤트는 버블링이 되는 대체할 수 있는 이벤트로 focusin, focusout, mouseover, mouseout이 있습니다.

<br>

### 4. 이벤트 위임에 대해 설명해주세요.

- 이벤트 위임은 여러 개의 하위 DOM 요소에 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말합니다. 이는 이벤트 타깃뿐만 아니라 상위 DOM 요소에서도 이벤트를 캐치할 수 있다는 점을 이용한 것입니다.
- 이벤트 위임을 사용하면 여러 개의 하위 DOM 요소에 일일이 이벤트 핸들러를 등록할 필요가 없고 하위 DOM 요소가 추가되더라도 이벤트 핸들러를 추가적으로 등록할 필요가 없다는 장점이 있습니다. 그러나 이벤트가 발생하는 하위 DOM 요소가 아닌 상위 DOM 요소에 이벤트 핸들러를 등록하기 때문에 이벤트 타깃이 개발자가 기대한 DOM 요소가 아닐 수 있습니다. 따라서 이벤트에 대한 반응이 필요한 DOM 요소인지 확인하기 위해 이벤트 타깃을 검사할 필요가 있습니다.

<br>

### 5. 일반적인 이벤트 객체와 커스텀 이벤트 객체의 차이점에 대해 설명해주세요.

- 일반적인 이벤트 객체는 사용자의 행위에 의해 이벤트가 발생하여 생성되는 이벤트 객체로 개발자가 이벤트 발생 시점을 감지할 수 없기 때문에 브라우저에게 이벤드 핸들러의 호출을 위임합니다.
- 커스텀 이벤트 객체는 개발자가 이벤트 생성자 함수를 명시적으로 호출하여 생성하므로 개발자가 이벤트 발생 시점을 지정할 수 있고 임의의 이벤트 타입과 이벤트 고유의 프로퍼티 값을 지정할 수 있습니다.
- 일반적인 이벤트 객체의 isTrusted 프로퍼티 값은 true, 커스텀 이벤트 객체의 istTrusted 프로퍼티 값은 false입니다.
- 일반적으로 이벤트 핸들러는 비동기적으로 동작하지만, 커스텀 이벤트 핸들러는 동기적으로 동작합니다.
- 이벤트 핸들러는 이벤트 어트리뷰트/프로퍼티, addEventListener 방식으로 등록할 수 있지만, 커스텀 이벤트 핸들러는 addEventListener 방식으로만 등록할 수 있습니다.
