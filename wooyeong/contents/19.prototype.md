# 프로토타입

자바스크립트는 프로토타입 기반 객체지향을 지원하는 멀티 패러다임 프로그래밍 언어이다. 자바스크립트를 이루고 있는 모든것이 객체이다.
즉, 자바스크립트는 클래스가 아닌 프로토타입을 기반으로 객체지향 모델을 제공한다.
_ES6에 클래스가 도입되었지만 기존 프로토 타입 기반 패턴의 문법적 설탕으로 볼 수 있다._

## 19.1 객체지향 프로그래밍

객체지향 프로그래밍이란 실세계의 사물을 인식하는 방식을 프로그래밍에 접목한 것으로 프로그램을 명령어, 함수의 집합으로 바라보는 명령형 프로그래밍에서 벗어나 여러개의 독립적 단위인 객체의 집합으로 바라보는 프로그래밍 패러다임이다.
실체가 특징이나 성징을 나타내는 속성을 갖고 있듯이 갹체는 속성을 통해 다른 객체와 구별된다. 객체는 이러한 속성 여러개를 하나의 단위로 구성한 복합적인 자료구조이다.
갹체는 상태를 나타내는 프로퍼티와 이러한 프로퍼티를 조작할 수 있는 동작인 메서드로 구성된다.

## 19.2 상속과 프로토타입

**자바스크립트는 프로토타입을 기반으로 상속을 구현**한다.

## 19.3 프로토타입 객체

프로토타입은 어떤 객체의 부모가 되는 객체로서, 자신의 프로퍼티 또는 메서드를 자식 객체가 되는 다른 객체와 공유한다. 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티와 메서드를 자신의 프로퍼티처럼 접근할 수 있다.
프로토타입은 해당 객체가 생성될 때 결정되고 그 참조가 [[ptotoype]]에 저장된다.
모든 객체는 자신의 프로퍼티를 참조하고 있는 [[prototype]] 이라는 내부 슬롯을 가지게 되며 접근자 프로퍼티 \_\_proto\_\_를 통해 해당 내부슬롯값에 접근할 수 있다.

### 19.3.1 \_\_proto\_\_ 접근자 프로퍼티

모든 객체는 \_\_proto\_\_ 접근자 프로퍼티를 통해 자신의 프로토타입 즉, 내부슬롯 [[ptotoype]]에 접근할 수 있다.
\_\_proto\_\_에 접근할 때는 함수 getter, setter를 통해 값이 호출되고 할당된다.
(+ \_\_proto\_\는 원칙적으로 내부슬롯 [[ptotoype]]에 접근할 수 있는 직접 방법이 없으나 간접적으로 접근할 수 있는 수단이다.)

#### \_\_proto\_\_ 는 접근자 프로퍼티다.

\_\_proto\_\_는 getter/setter 접근자 함수를 통해 [[ptotoype]] 내부슬롯값을 가져오거나 할당한다.

#### \_\_proto\_\_ 는 상속을 통해 사용된다.

\_\_proto\_\_으로 프로토타입에 접근함으로서 \_\_proto\_\_가 자체 프로퍼티처럼 느껴지지만 \_\_proto\_\_는 상위 객체의 prototype의 프로퍼티이다.(상속받은것)
즉 [상위객체].protoype.\_\_proto\_\_ 이다.

#### \_\_proto\_\_ 접근자 프로퍼티를 통해 프로퍼티에 접근하는 이유

프로토타입에 접근하기 위해 \_\_proto\_\_ 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 형성되는 것을 방지하기 위함이다.
만약 A.\_\_proto\_\_ = B, B.\_\_proto\_\_ = A를 할당 시 서로가 자신의 프로토타입이 되는 비정상적인 프로토타입 체인이 형성된다 .따라서 접근자 프로퍼티를 사용하여 체크 후 프로토타입을 교체하도록 구현한 것이다.

### 19.3.2 함수객체의 prototype 프로퍼티

함수 객체는 일반객체와 달리 prototype 프로퍼티를 갖게되는데 이는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 즉 해당 함수로 생성될 객체의 포로토타입을 가리킨다.
생성자 함수로 작동할 수 없는 화살표 함수, 축약표현 메서드는는 prototype 프로퍼티가 존재하지 않는다.
함수 객체의 prototype 프로퍼티는 생성자 함수가 평가,정의 되어 함수 객체를 생성하는 시점에 함께 생성된다.(런타임 이전)
또한 이렇게 생성된 prototype 객체의 프로토타입은 언제나 Object.prototype이다.

### 19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수

모든 프로토타입은 contructor 프로퍼티를 갖는데 이 contructor프로퍼티는 자신을 참고하고 있는 생성자 함수를 가리킨다. 결국 해당 프로토타입을 상속받은 모든 객체도 contructor 프로퍼티를 갖게되므로, 생성자 함수로 생성된 모든 객체의 contrucotr가 있으며 그 contructor는 생성자 함수를 가리키게 된다

### 19.5 프로토타입의 생성 시점

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 단, 생성자 함수는 사용자가 정의한 생성자함수와 기본 빌트인 생성자 함수로 구분되는데, 사용자 정의 생성자 함수는 해당 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입이 함께 생성되며, 모든 빌트인 생성자함수는 전역객체 생성시점에 생성된다.

## 19.7 프로토타입 체인

모든 객체는 프로토타입을 통해 상위 -하위의 계층 구조를 가지게 된다.
자바스크립트는 객체의 프로퍼티에 접근하고자 할때 해당 객체에 찾으려는 프로퍼티가 없을 때, [[prototype]] 내부슬롯 참조를 따라 자신의 부모 역할을 하는 프로토타입에서 다시 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라고 한다.
프로토 타입의 종점은 언제나 Object.prototype이다. Object.prototype은 null을 반환하며 프로토타입 최상단에서도 검색할 수 없는 경우 undefined를 반환한다.
_+스코포 체인은 식별자 검색을 위한 매커니즘, 프로토타입 체인은 프프로퍼티 검색을 위한 메커니즘이다._

## 19.8 오버라이딩과 프로퍼티 셰도잉

프로토타입이 소유한 프로퍼티와 동일한 이름의 프로퍼티를 인스턴트에 추가하면 프로포타입 프로퍼티가 덮어씌워지진 않고 인스턴스의 프로퍼티로 추가된다.(오버라이딩) 이렇게 상속관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 셰도잉이라고 한다.

\_\_proto\_\_ 는 es6에서 지원되지만\_\_proto\_\_ 를 직접사용하는 것은 권장하지 않는다. 일부 객체는 프로토타입을 참조하지않는 경우가 있기때문에\_\_proto\_\_ 를 사용할 수 없을 수 있다.
\_\_proto\_\_ 대신 Object.getPrototypeOf(대상객체) / Object.setPrototypeOf를 사용할 수 있다.

참고
객체리터럴로 생성한 객체도 Object 생성자 함수와 연결된다. 실제로 내부도 객체리터럴이 Object 생성자 함수를 사용하는 것은 아니고 모든 프토로타입과 생성자 함수는 쌍으로 존재해야하므로, 객체 리터럴로 선언한 객체도 가상적인 생성자 함수가 필요하기 때문에 그냥 그렇게 쓴다…

## 19.9 프로토타입의 교체

객체의 프로토타입을 교체하는것도 가능하다. 생성자 함수의 prototype을 변경하거나 \_\_proto\_\_ 접근자 프로퍼티를 통해 교체할 수 있다.  
단, 생성자 함수의 prototype을 변경하는 것은 미래의 생성될 인스턴스의 프로토타입을 교체하는 것이고 \_\_proto\_\_ 접근자 프로퍼티를 이용하는 것은 이미 생성된 객체의 프로토타입을 교체하는것이다.(기존 프로토타입과 연결이 끊어짐)

## 19.10 instanceof 연산자

instanceof 연산자는 이항 연산자로서 좌변에 객체, 우변에 생성자 함수를 피연산자로 사용한다.
우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변 객체의 프로토타입 체인상에 존재하면 true, 없다면 false를 반환한다.
즉, 상속하여 생성된 객체도 프로토타입 체인상에 해당 객체가 존재하지않는다면(변경에 의해) false를 반환한다.

## 19.12 정적 프로퍼티와 메서드

정적 프로퍼티와 메서드는 생성자함수로 인스턴스트를 생성하지 않아도 접근가능한 함수 자체의 프로퍼티와 메서드를 말한다.
정적 프로퍼티/메서드는 프로토타입 체인상에 존재하지 않기때문에 인스턴스로 접근이 불가능하다.
생성자 함수의 메서드는 정적 메서드, 생성자 함수의 prototype 속성의 메서드는 프로토타입 체인 상 메서드가 된다

## 19.13 프로퍼티 존재 확인

### 19.13.1 in 연산자

in 연산자는 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인한다. 이때 프로퍼티는 해당 객체 고유의 프로퍼티뿐만 아니라 해당 객체가 상속받은 프로토타입 체인상 모든 프로퍼티를 확인한다.

### 19.13.2 Object.prototype.hasOwnProperty 메서드

Object.prototype.hasOwnProperty를 사용해도 해당 객체에 특정 프로퍼티가 존재하는지 확인할 수 있다. 이때 해당 객체 고유의 프로퍼티인 경우만 true를 반환하며 프로퍼티가 없거나 해당 객체가 상속받은 프로토타입의 프로퍼티 인 경우 false를 반환한다.

## 19.14 프로퍼티 열거

### 19.14.1 for…in문

객체의 모든 프로퍼티를 열거하고 싶다면 for…in 문을 사용한다. for…in의 열거대상은 순회 대상 객체 고유의 프로퍼티외에도 상속받은 프로퍼티까지 열거하여 순회한다. 즉 객체의 프로토타입 체인 상 존재하는 모든 프로퍼티 중 [[Enumerable]]가 false인 프로퍼티를 제외하고 모든 프로퍼티를 순회하며 열거 한다.
만약 순회하고 싶지않은 프로퍼티는 프로퍼티의 어트리뷰트 [[Enumerable]]를 false로 설정한다. (toString과 가은 속성은 이미 [[Enumerable]] 이 false이기때문에 열거되지않는다)

### 19.14.2 Object.keys/values/entries 메서드

상속받은 프로퍼티가 아닌 객체 고유의 프로퍼티만 순회하려면 Object.ptototype.hasOwnProperty를 활용하여 검증하거나 Object.keys등을 사용한다.
