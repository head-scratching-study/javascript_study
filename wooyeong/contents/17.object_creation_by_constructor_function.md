## 17.1 Object 생성자 함수

new 연산자로 Object 생성자 함수 호출 시 빈 객체가 반환된다. 반환된 빈객체에 프로퍼티와 메서드를 추가할 수 있다.
생성자 함수란 new 연산자와 함께 호출하여 인스턴스를 생성하는 함수를 말한다.

> _인스턴스 : 생성자 함수에 의해 생성된 객체_

자바스크립트는 Object외에도 String, Number, Boolean, Function,Array등의 빌트인 생성자 함수를 제공한다.
그러나 객체 생성시 반드시 생성자함수를 사용해야하는것은 아니다. 객체 리터럴을 사용하는 것이 더욱 간편하다.

## 17.2 생성자 함수

## 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

객체리터럴에 의한 객체 생성은 간편하고 직관적이다. 그러나 단 하나의 객체만을 생성하기 때문에 동일한 프로퍼티 구조를 갖는 객체를 여러개 생성할 때는 비효율적이다.

## 17.2.2 생성자 함수에 의한 객체 생성 방식의 문제점

생성자 함수에 의한 객체 생성은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스) 처럼 사용할 수 있기 때문에 프로퍼티 구조가 동일한 객체를 간편하게 여러개 생성할 수 있다.
생성자 함수는 다른 클래스기반 객체지향언어의 생성자와는 달리 그 형식이 정해져있지 않으며, 일반 함수와 동일한 방식으로 생성자함수를 정의한다. 다만 **new 연산자와 함께 호출한다면 해당 함수는 생성자 함수로 동작하게 된다.**

## 17.2.3 생성자 함수의 인스턴스 생성 과정

생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 여러개 생성하는 것으로 그 단계를 크게 1. 인스턴스 생성과 2. 생성된 인스턴스를 초기화(프로퍼티 추가 및 값 할당) 하는 것이다.

### 1. 인스턴스 생성과 this 바인딩

생성자 함수내에는 인스턴스를 명시적으로 생성하고 반환하는 코드는 보이지않는다. 이는 생성자 함수 내부에서 암묵적으로 빈 객체가 생성되고 반환되기 때문이다. 이 빈 객체가 바로 생성자 함수가 생성한 인스턴스이다.
또한 생성자 함수 내부에서 이 인스턴스는 this에 바인딩된다.

### 2. 인스턴스 초기화

생성자 함수 코드가 차례대로 실행되면서 this에 바인딩된 인스턴스가 초기화된다. 즉 프로퍼티나 메서드가 추가되고 전달받은 초기값으로 프로퍼티를 초기화한다.

### 3. 인스턴스 반환

생성자 함수 내부 코드가 모두 실행되면 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 만약 this가 아닌 다른 객체를 반환하면 해당 객체가 반환되고, 객체가 아닌 원시값을 반환하거나 반환된 값이 없으면 암묵적으로 this가 반환된다.

## 17.2.4 내부 메서드 [[Call]] [[Constructor]]

함수는 일반 객체이지만, 호출할 수 있는 객체이기때문에 일반 객체가 갖고있지 않은 함수 객체만을 위한 내부 슬롯과 내부 메서드가 존재한다.
함수객체만을 위한 내부슬롯은 [[Enviroment]],[[FormalParameters]]이며 내부 메서드 [[Call]] [[Constructor]]를 갖는다.

만약, 함수가 일반 함수로서 호출된다면 내부 메서드 [[Call]]이 호출되고 new 와함께 생성자함수로 호출된다면 내부메서드 [[Constructor]]가 호출된다.

내부 메서드 [[Call]]을 갖는 함수객체를 callale, 즉 호출할 수 있는 객체라고 하고 내부 메서드 [[Constructor]]를 갖는 함수객체를 constuctor, 즉 생성자함수로서 호출할 수 있는 함수라고 하며 그렇지 않은 함수를 non-contructor이라고 한다.

모든 함수객체는 callable하지만 모든 함수객체가 constuctor인것은 아니다.
즉, 모든 함수객체는 호출할 수 있지만 모든 함수객체를 생성자함수로서 호출할 수 있는 것은 아니다.

## 17.2.4 constuctor와 non-constuctor의 구분

자바스크립트 엔진은 함수 객체 생성할 때 함수 정의 방식에 따라 함수를 constuctor와 non-constuctor로 구분한다.

- constuctor 함수에는 함수선언문, 함수 표현식, 클래스가 해당한다
- non-constuctor함수에는 메서드(ES6메서드 축약표현), 화살표 함수가 포함된다.
  _(주의할 것은 프로퍼티의 값으로 함수는 일반적으로 모두 메서드라부르지만 ECMASCript에서 명시한 메서드란 ES6의 메서드 축약표현만을 의미한다. 즉 프로퍼티에 할당된 일반함수는 contructor이다)_

non-contructor인 함수를 생성자 함수로서 호출하면 에러가 발생한다.

## 17.2.6 new 연산자

함수를 new 연산자와 함께 호출하면 내부 메서드 [[Constructor]]이 호출되며 단, 함수는 contructor이어야 한다.
반대로 contructor함수를 new 연산자 없이 호출한다면 [[Call]]이 호출된다.

## 17.2.7 new.target

생성자 함수가 new 연산자 없이 호출되는것을 방지하기 위해 파스칼케이스 컨벤션을 사용하지만 실수는 발생할 수 있다. 이러한 위험을 위해 ES^dpsms new target을 지원한다.
new.target은 this와 유사하게 construcotr인 함수내에서 암묵적인 지역변수와 같이 사용되며 메타 프로퍼티라고 부른다.
new.target을 사용하면 해당 함수가 new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있다.
함수가 생성자함수로 호출되었다면 new.target는 함수 자신을 가리키며 반대로 일반함수로 호출되었다면 new.target는 undefined이다.

new.target를 통해 확인하기 new연산자와 재귀 호출을 통해 생성자 함수 호출을 보장할 수 있다.

> new.target은 ES6부터 지원되므로 지원되지 않는 버전에서는 스코프 세이프 생성자 패턴을 사용할 수 있다. (this instanceof Circle)

대부분의 빌트인 생성자 함수는 내부에서 new연산자와 함께 호출되었는지를 확인한다.
Object는 new 연산자없이 호출하여도 new 연산자와 함께 호출했을때와 동일하게 작동한다.
String,Number은 일반 원시값을 반환한다.
