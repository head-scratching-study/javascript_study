# 원시 값과 객체의 비교

자바스크립트가 제공하는 7가지 데이터 타입은 크게 원시타입과 객체타입으로 구분할 수 있다.
원시타입과 객체타입은 다음 3가지 측면에서 차이를 가진다.

1. 원시 값은 변경 불가능한 값이고 객체타입의 값은 변경 가능한 값이다.
2. 원시값을 변수에 할당하면 변수(실제 메모리)에는 실제 값이 저장된다. 반면 객체를 변수에 할당하면 변수에는 객체의 참조 값이 저장된다.
3. 원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달되며 이를 값에 의한 전달이라고한다. 반면 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되고 이를 참조에 의한 전달이라고한다.

## 11.1 원시값

### 11.1.1 변경 불가능한 값

원시 타입의 값은 읽기 전용값으로 변경 불가능한값이다.이때 변경 불가능하다는 것은 변수가 아닌 값이다. 변수는 값을 저장하기 위한 메모리 공간을 식별하기 위해 붙인 이름을 의미하며 값이 해당 메모리 공간 즉 변수에 할당된다. 원시값은 변경 불가능하다는 말은 원시 값 자체를 변경 불가능하다는 것이며 변수는 재할당이 가능하다.
재할당이 금지된 변수는 상수라고한다. 상수는 변수에 할당된 값을 교체할 수 없다.

원시 값은 변경이 불가능하기때문에 변수 값을 변경하려면 새로운 메모리 공간을 확보하여 재할당한 값을 저장 후 변수가 참조하던 메모리 공간의 주소를 변경한다. 이러한 특성을 불변성이라고 한다.
불변성을 갖는 원시값을 할당한 변수는 재할당으로만 변수 값 변경이 가능하다.

### 11.1.2

원시값인 문자열은 0개 이상의 문자로 이루어진 집합을 의미하며 1개 문자는 2바이트의 메모리 공간에 저장된다. 따라서 문자열은 몇개의 문자로 이루어졌느냐에 따라 필요한 메모리 공간이 달라진다. (1개 문자열 -> 2바이트, 10개 문자열 -> 20바이트)
위와 같은 이유로 C에서는 하나의 문자를 위한 데이터 타입만 존재하며 문자열을 문자의 배열로 처리한다.
자바스크립트는 원시타입인 문자열을 제공하며 문자열이 생성된 이후에는 메모리에 저장된 값을 바꿀 수 없다.

문자열은 유사배열 객체이면서 이터러블이므로 각 문자에 접근할 수는 있으나, 원시값이기 때문에 문자를 변경하려해도 반영되지않는다.

### 11.1.3 값에 의한 전달

원시값을 갖는 변수를 다른 변수에 복사하여 전달하는 것을 **값에 의한 전달** 이라고한다. 복사될 때 값은 새로운 메모리 공간을 확보하여 값을 복사한다. 즉 각 변수가 가리키는 값은 별개의 값이다. 특정 변수의 값을 변경해도 복사한 다른 하나의 변수의 값에는 어떠한 영향도 주지 않는다.
파이썬과 같은 경우는 변수에 원시값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이루어졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작한다.
중요한 것은 재할당이 이루어질 때 결국 두 변수의 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되므로 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다.

#### 값에 의한 전달

값에 의한 전달 이라는 용어는 자바스크립트용어가 아니며 ECMAScript 사양에도 존재하지 않는다. 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 값이 저장된 메모리 주소가 전달된다.변수와 같은 식별자는 값 그차제가 아니라 값이 저장된 메모리 주소를 기억하고 있다.  
값에 의한 전달도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달하고 해당 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.

## 11.2 객체

객체는 프로퍼티의 갯수가 정해져 있지 않으며 동적으로 추가,삭제될 수 있다. 또한 프로퍼티의 값에 제약도 없으므로 객체는 원시 값과 같이 확보해야할 메모리 공간의 크기를 미리 정해둘 수 없다.
객체는 복합적 자료구조이므로 객체 관리 방식이 원시값과 비교하여 복잡하고 구현 방식도 브라우저마다 다르다. 원시값은 상대적으로 적은 메모리를 소비하고 객체는 경우에 따라 매우 큰 메모리를 소비한다.
객체는 원시값과는 다른 방식으로 동작하도록 설계되어있다.

```
자바스크립트의 객체는 프로퍼티키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다. 대부분의 자바스크립트 엔진은 해시테이블과 유사하지만 성능을 고려한 더 나은 방법으로 객체를 구현한다.
자바,C++같은 클래스 기반 객체지향언어는 사전 정의된 클래스를 기반으로 인스턴스를 생성한다. 객체 생성 이전에 이미 프로퍼티와 메서드가 정해져 있으며 그대로 객체(인스턴스)가 생성된다. 객체 생성 이후에는 프로퍼티나 메서드 추가가 불가능하다. 반면 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 객체 생성 이후에도 프로퍼티와 메서드를 추가할 수 있다. 이는 매우 편리하지만 성능면에서 클래스 기반 객체지향언어보다 생성과 프로퍼티 접근에 더 많은 비용을 필요로 한다. 따라서 V8자바스크립트 엔진에서는 프로퍼티 접근 시 히든 클래스라는 방식을 사용한다. 히든 클래스는 자바와 같은 고정된 객체 레이아웃과 유사하게 동작한다.
```

### 11.2.1 변경 가능한 값

객체 타입의 값, 즉 객체는 변경 가능한 값이다.
원시 값이 변수에 할당하면 변수를 통해 바로 원시값이 저장된 메모리 공간에 바로 접근가능한것에 반해, 변수에 객체를 할당하면 변수를 통해 참조값이 저장된 메모리공간에 접근할 수 있으며 참조값이란 생성된 객체가 저장된 메모리 공간의 주소이다.
객체는 변경 가능한 갑이므로 재할당 없이 객체를 바로 변경할 수 있다. 객체를 변경하여도 변수를 재할당한것은 아니므로 변수에 저장된 참조값은 변경되지 않는다.
객체는 생성하고 관리하는 방식이 매우 복잡하므로 원시값처럼 복사하여 생성하는것은 비용이 많이 든다. 따라서 효율적인 메모리 관리를 위해 객체는 변경 가능한 값으로 설계되어 있다.
단, 이러한 객체의 특성으로 객체는 여러개의 식별자가 하나의 객체를 공유할 수 있다.

```
얕은 복사와 깊은 복사
- 객체를 프로퍼티 값으로 갖는 경우 얕은 복사는 한단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.
- 얕은 복사와 깊은 복사로 생성된 객체는 원본과  참조값이 다르므로 다른 객체지만 얕은 복사 내부에 중첩되어 있는 객체의 경우 참조값을 복사하므로 같은 객체를 가리키는 반면 깊은 복사는 중첩 객체까지 모두 복사하여 완전히 다른 복사본 객체를 생성한다는 차이가 있다.
```

### 11.2.1 참조에 의한 전달

객체를 가리키는 변수를 다른 변수에 할당하면 원본 객체를 가리키는 주소, 참조값이 복사되어 전달된다. 이를 **참조에 의한 전달** 이라고한다.
참조의 의한 전달은 각각의 참조값이 저장된 메모리 공간은 다르지만, 참조값이 가리키는 객체는 모두 동일한 객체이다. 즉 두 개의 식별자(변수)가 하나의 객체를 공유하게 된다. 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주게 된다.

결국 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하고 있는, 가리키고 있는 메모리 공간에 저장된 값을 복사한다는 면에서는 동일하다.
그러나 해당 메모리 공간에 저장된 값이 원시값이냐 참조값이냐 차이가 있을 뿐이다. 따라서 자바스크립트에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만이 존재한다고 할 수 있다.
